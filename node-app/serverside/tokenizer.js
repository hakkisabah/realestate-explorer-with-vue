const jwt = require("jsonwebtoken")
const dotenv = require('dotenv');
const dotresult = dotenv.config();
const bcrypt = require('bcrypt')
const message = require('./messages');
if (dotresult.error) {
    throw dotresult.error;
}
let tokenizer = function () {
}

tokenizer.prototype.sign = function (payload) {
    return new Promise(resolve => {
        jwt.sign({
                data: payload
            }, process.env.JWTSECRET, {expiresIn: process.env.JWTEXPIRYDEVELOPMENT},

            function (err, token) {
                if (err) resolve({error: message.errors.tokenizer.signError, result: false});
                else resolve({success: message.success.tokenizer.signSucces, result: token})
            })
    })
}

tokenizer.prototype.verify = function (token) {
    return new Promise(resolve => {
        jwt.verify(token, process.env.JWTSECRET, function (err, verified) {
            if (err) return resolve({error: message.errors.tokenizer.verifyError, result: false})
            return resolve({success: message.success.tokenizer.verifySuccess, result: verified})
        });
    })
}

tokenizer.prototype.passCrypt = function (pass) {
    return new Promise(resolve => {
        bcrypt.hash(pass, 10, function (err, hash) {
            if (err) return resolve(false)
            return resolve(hash)
        })
    })
}

tokenizer.prototype.passDecrypt = async function (pass, hash) {
    return new Promise(resolve => {
        bcrypt.compare(pass, hash, function (err, result) {
            if (err) return resolve(false)
            return resolve(result)
        })
    })
}
tokenizer.prototype.getRandomID = function () {
    // code from https://gist.github.com/gordonbrander/2230317
    // Generate unique IDs for use as pseudo-private/protected names.
    // Similar in concept to
    // <http://wiki.ecmascript.org/doku.php?id=strawman:names>.
    //
    // The goals of this function are twofold:
    //
    // * Provide a way to generate a string guaranteed to be unique when compared
    //   to other strings generated by this function.
    // * Make the string complex enough that it is highly unlikely to be
    //   accidentally duplicated by hand (this is key if you're using `ID`
    //   as a private/protected name on an object).
    //
    // Use:
    //
    //     var privateName = ID();
    //     var o = { 'public': 'foo' };
    //     o[privateName] = 'bar';

    // Math.random should be unique because of its seeding algorithm.
    // Convert it to base 36 (numbers + letters), and grab the first 9 characters
    // after the decimal.
    return Math.random().toString(36).substr(2, 9);
};
module.exports = new tokenizer()
